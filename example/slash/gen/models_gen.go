// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gen

import (
	"fmt"
	"io"
	"strconv"
)

type AddTaskInput struct {
	Title     string   `json:"title"`
	Completed bool     `json:"completed"`
	User      *UserRef `json:"user"`
}

type AddTaskPayload struct {
	Task    []*Task `json:"task"`
	NumUids *int    `json:"numUids"`
}

type AddUserInput struct {
	Username string     `json:"username"`
	Name     *string    `json:"name"`
	Tasks    []*TaskRef `json:"tasks"`
}

type AddUserPayload struct {
	User    []*User `json:"user"`
	NumUids *int    `json:"numUids"`
}

type AuthRule struct {
	And  []*AuthRule `json:"and"`
	Or   []*AuthRule `json:"or"`
	Not  *AuthRule   `json:"not"`
	Rule *string     `json:"rule"`
}

type CustomHTTP struct {
	URL               string     `json:"url"`
	Method            HTTPMethod `json:"method"`
	Body              *string    `json:"body"`
	Graphql           *string    `json:"graphql"`
	Mode              *Mode      `json:"mode"`
	ForwardHeaders    []string   `json:"forwardHeaders"`
	SecretHeaders     []string   `json:"secretHeaders"`
	SkipIntrospection *bool      `json:"skipIntrospection"`
}

type DateTimeFilter struct {
	Eq *string `json:"eq"`
	Le *string `json:"le"`
	Lt *string `json:"lt"`
	Ge *string `json:"ge"`
	Gt *string `json:"gt"`
}

type DeleteTaskPayload struct {
	Msg     *string `json:"msg"`
	NumUids *int    `json:"numUids"`
}

type DeleteUserPayload struct {
	Msg     *string `json:"msg"`
	NumUids *int    `json:"numUids"`
}

type FloatFilter struct {
	Eq *float64 `json:"eq"`
	Le *float64 `json:"le"`
	Lt *float64 `json:"lt"`
	Ge *float64 `json:"ge"`
	Gt *float64 `json:"gt"`
}

type IntFilter struct {
	Eq *int `json:"eq"`
	Le *int `json:"le"`
	Lt *int `json:"lt"`
	Ge *int `json:"ge"`
	Gt *int `json:"gt"`
}

type StringExactFilter struct {
	Eq *string `json:"eq"`
	Le *string `json:"le"`
	Lt *string `json:"lt"`
	Ge *string `json:"ge"`
	Gt *string `json:"gt"`
}

type StringFullTextFilter struct {
	Alloftext *string `json:"alloftext"`
	Anyoftext *string `json:"anyoftext"`
}

type StringHashFilter struct {
	Eq *string `json:"eq"`
}

type StringRegExpFilter struct {
	Regexp *string `json:"regexp"`
}

type StringTermFilter struct {
	Allofterms *string `json:"allofterms"`
	Anyofterms *string `json:"anyofterms"`
}

type Task struct {
	ID        string `json:"id"`
	Title     string `json:"title"`
	Completed bool   `json:"completed"`
	User      *User  `json:"user"`
}

type TaskFilter struct {
	ID        []string              `json:"id"`
	Title     *StringFullTextFilter `json:"title"`
	Completed *bool                 `json:"completed"`
	And       *TaskFilter           `json:"and"`
	Or        *TaskFilter           `json:"or"`
	Not       *TaskFilter           `json:"not"`
}

type TaskOrder struct {
	Asc  *TaskOrderable `json:"asc"`
	Desc *TaskOrderable `json:"desc"`
	Then *TaskOrder     `json:"then"`
}

type TaskPatch struct {
	Title     *string  `json:"title"`
	Completed *bool    `json:"completed"`
	User      *UserRef `json:"user"`
}

type TaskRef struct {
	ID        *string  `json:"id"`
	Title     *string  `json:"title"`
	Completed *bool    `json:"completed"`
	User      *UserRef `json:"user"`
}

type UpdateTaskInput struct {
	Filter *TaskFilter `json:"filter"`
	Set    *TaskPatch  `json:"set"`
	Remove *TaskPatch  `json:"remove"`
}

type UpdateTaskPayload struct {
	Task    []*Task `json:"task"`
	NumUids *int    `json:"numUids"`
}

type UpdateUserInput struct {
	Filter *UserFilter `json:"filter"`
	Set    *UserPatch  `json:"set"`
	Remove *UserPatch  `json:"remove"`
}

type UpdateUserPayload struct {
	User    []*User `json:"user"`
	NumUids *int    `json:"numUids"`
}

type User struct {
	Username string  `json:"username"`
	Name     *string `json:"name"`
	Tasks    []*Task `json:"tasks"`
}

type UserFilter struct {
	Username *StringHashFilter  `json:"username"`
	Name     *StringExactFilter `json:"name"`
	And      *UserFilter        `json:"and"`
	Or       *UserFilter        `json:"or"`
	Not      *UserFilter        `json:"not"`
}

type UserOrder struct {
	Asc  *UserOrderable `json:"asc"`
	Desc *UserOrderable `json:"desc"`
	Then *UserOrder     `json:"then"`
}

type UserPatch struct {
	Name  *string    `json:"name"`
	Tasks []*TaskRef `json:"tasks"`
}

type UserRef struct {
	Username *string    `json:"username"`
	Name     *string    `json:"name"`
	Tasks    []*TaskRef `json:"tasks"`
}

type DgraphIndex string

const (
	DgraphIndexInt      DgraphIndex = "int"
	DgraphIndexFloat    DgraphIndex = "float"
	DgraphIndexBool     DgraphIndex = "bool"
	DgraphIndexHash     DgraphIndex = "hash"
	DgraphIndexExact    DgraphIndex = "exact"
	DgraphIndexTerm     DgraphIndex = "term"
	DgraphIndexFulltext DgraphIndex = "fulltext"
	DgraphIndexTrigram  DgraphIndex = "trigram"
	DgraphIndexRegexp   DgraphIndex = "regexp"
	DgraphIndexYear     DgraphIndex = "year"
	DgraphIndexMonth    DgraphIndex = "month"
	DgraphIndexDay      DgraphIndex = "day"
	DgraphIndexHour     DgraphIndex = "hour"
)

var AllDgraphIndex = []DgraphIndex{
	DgraphIndexInt,
	DgraphIndexFloat,
	DgraphIndexBool,
	DgraphIndexHash,
	DgraphIndexExact,
	DgraphIndexTerm,
	DgraphIndexFulltext,
	DgraphIndexTrigram,
	DgraphIndexRegexp,
	DgraphIndexYear,
	DgraphIndexMonth,
	DgraphIndexDay,
	DgraphIndexHour,
}

func (e DgraphIndex) IsValid() bool {
	switch e {
	case DgraphIndexInt, DgraphIndexFloat, DgraphIndexBool, DgraphIndexHash, DgraphIndexExact, DgraphIndexTerm, DgraphIndexFulltext, DgraphIndexTrigram, DgraphIndexRegexp, DgraphIndexYear, DgraphIndexMonth, DgraphIndexDay, DgraphIndexHour:
		return true
	}
	return false
}

func (e DgraphIndex) String() string {
	return string(e)
}

func (e *DgraphIndex) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DgraphIndex(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DgraphIndex", str)
	}
	return nil
}

func (e DgraphIndex) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HTTPMethod string

const (
	HTTPMethodGet    HTTPMethod = "GET"
	HTTPMethodPost   HTTPMethod = "POST"
	HTTPMethodPut    HTTPMethod = "PUT"
	HTTPMethodPatch  HTTPMethod = "PATCH"
	HTTPMethodDelete HTTPMethod = "DELETE"
)

var AllHTTPMethod = []HTTPMethod{
	HTTPMethodGet,
	HTTPMethodPost,
	HTTPMethodPut,
	HTTPMethodPatch,
	HTTPMethodDelete,
}

func (e HTTPMethod) IsValid() bool {
	switch e {
	case HTTPMethodGet, HTTPMethodPost, HTTPMethodPut, HTTPMethodPatch, HTTPMethodDelete:
		return true
	}
	return false
}

func (e HTTPMethod) String() string {
	return string(e)
}

func (e *HTTPMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HTTPMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HTTPMethod", str)
	}
	return nil
}

func (e HTTPMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Mode string

const (
	ModeBatch  Mode = "BATCH"
	ModeSingle Mode = "SINGLE"
)

var AllMode = []Mode{
	ModeBatch,
	ModeSingle,
}

func (e Mode) IsValid() bool {
	switch e {
	case ModeBatch, ModeSingle:
		return true
	}
	return false
}

func (e Mode) String() string {
	return string(e)
}

func (e *Mode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Mode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Mode", str)
	}
	return nil
}

func (e Mode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TaskOrderable string

const (
	TaskOrderableTitle TaskOrderable = "title"
)

var AllTaskOrderable = []TaskOrderable{
	TaskOrderableTitle,
}

func (e TaskOrderable) IsValid() bool {
	switch e {
	case TaskOrderableTitle:
		return true
	}
	return false
}

func (e TaskOrderable) String() string {
	return string(e)
}

func (e *TaskOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaskOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaskOrderable", str)
	}
	return nil
}

func (e TaskOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserOrderable string

const (
	UserOrderableUsername UserOrderable = "username"
	UserOrderableName     UserOrderable = "name"
)

var AllUserOrderable = []UserOrderable{
	UserOrderableUsername,
	UserOrderableName,
}

func (e UserOrderable) IsValid() bool {
	switch e {
	case UserOrderableUsername, UserOrderableName:
		return true
	}
	return false
}

func (e UserOrderable) String() string {
	return string(e)
}

func (e *UserOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderable", str)
	}
	return nil
}

func (e UserOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
